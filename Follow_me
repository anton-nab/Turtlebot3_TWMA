import rclpy
from rclpy.node import Node

from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist




NbTargetMax = 100
SizeTarget = 3
DegreeToTargetRaw = 60
TargetAverageRange = 0.5
TargetMinRange = 0.1
TargetMaxRange = 1.5
TargetGapScan = 0.3

CalculatedDegreeToTarget = DegreeToTargetRaw - SizeTarget
HalfDegreeToTarget = DegreeToTargetRaw / 2  


class FollowMe(Node):

    def __init__(self):
        super().__init__('FollowMe')

        self.ScanAnyDegree = []
        self.ScanFrontDegree = []
        self.Targets = []

        self.publisher_ = self.create_publisher(Twist, 'cmd_vel', 10)

        self.subscription = self.create_subscription(
            LaserScan,
            'scan',
            self.listener_callback,
            10)
        
    def listener_callback(self, msg):
        
        self.SaveValueScan(msg.ranges)
        self.SaveChoiceScanDegree(self.ScanAnyDegree)
        self.ReachTarget()

    # Sauvegarde les valeurs du Lydar dans le tableau Targets

    def SaveValueScan(self, ValueTab):
        ''''
        Sauvegarde les valeurs du scan dans un tableau 
        '''
        
        self.ScanAnyDegree = []
        
        for i in range(360):

            try: 
                val = float(ValueTab[i])
            except:
                val = 0

            self.ScanAnyDegree.append(val)
            
    def SaveChoiceScanDegree(self, ScanTab):

        self.ScanFrontDegree = []
        #-1 ?
        for i in range(len(ScanTab) - int(HalfDegreeToTarget), len(ScanTab)):
            self.ScanFrontDegree.append(ScanTab[i])
        

        for i in range(int(HalfDegreeToTarget)):    
            self.ScanFrontDegree.append(ScanTab[i])

    #Permet le d√©placement du robot

    def Move(self, x, z):
        
        order = Twist()

        order.angular.z = z
        order.linear.x  = x
        self.publisher_.publish(order)

    def CalculatedMove(self, Tab):
        
        linearGap = Tab[0]
        angularGap = Tab[1] 

        x = (TargetAverageRange - linearGap) / 5


        y = (angularGap - HalfDegreeToTarget) / 50
        

        print(y)


        self.Move(- x,  y)
        

    # Algorythme du "Follow me"

    def TargetSaver(self, i):

        TargetMoy = (self.ScanFrontDegree[i] + self.ScanFrontDegree[i+1] + self.ScanFrontDegree[i+2]) / 3
        if(TargetMinRange < TargetMoy < TargetMaxRange):

            self.Targets.append([TargetMoy, i+1])

        i = 0 

    def TargetIdentifier(self, i):

        validation = 0

        for j in [1, SizeTarget] : 

            if self.ScanFrontDegree[i+j] > self.ScanFrontDegree[i] + TargetGapScan or self.ScanFrontDegree[i+j] < self.ScanFrontDegree[i] - TargetGapScan:

                break

            validation = validation + 1 

        return validation

    def TargetCentral(self):
        
        for i in range(CalculatedDegreeToTarget) :

            validation = self.TargetIdentifier(i)
            
            if validation == 2 :

                self.TargetSaver(i)

    def ReachTarget(self):

        self.TargetCentral()

        NbTarget = len(self.Targets)
       
        if NbTarget > NbTargetMax or NbTarget == 0 :

            self.Move(0.0, 0.0)
        
        elif NbTarget > 1 :
            
            mem = 0

            for _ in range(NbTarget) :

                if self.Targets[_][0] < self.Targets[mem][0] :

                    mem = _

            self.CalculatedMove(self.Targets[mem])

        elif NbTarget == 1 :

            self.CalculatedMove(self.Targets[0])
        
        self.Targets = []





def main(args=None):

    rclpy.init(args=args)

    follow_me = FollowMe()

    rclpy.spin(follow_me)

    # Destroy the node explicitly
    # (optional - otherwise it will be done automatically
    # when the garbage collector destroys the node object)
    follow_me.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
