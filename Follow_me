import rclpy
from rclpy.node import Node

from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist


Targets = []

NbTargetMax = 10
SizeTarget = 2
DegreeToTargetRaw = 40
TargetAverageRange = 1.0
TargetMinRange = 0.75
TargetMaxRange = 1.25

CalculatedDegreeToTarget = DegreeToTargetRaw - SizeTarget
HalfDegreeToTarget = DegreeToTargetRaw / 2  




class FollowMe(Node):

    def __init__(self):
        super().__init__('FollowMe')

        self.ScanAnyDegree = []
        self.ScanFrontDegree = []

        self.publisher_ = self.create_publisher(Twist, 'cmd_vel', 10)

        self.subscription = self.create_subscription(
            LaserScan,
            'scan',
            self.listener_callback,
            10)
        
        def listener_callback(self, msg):
            
            self.SaveValueScan()
            self.SaveChoiceScanDegree()
            self.ReachTarget()

    # Sauvegarde les valeurs du Lydar dans le tableau Targets

    def SaveValueScan(self, ValueTab):
        ''''
        Sauvegarde les valeurs du scan dans un tableau 
        '''
        
        self.ScanAnyDegree = []
        
        for i in range(360):

            try: 
                val = float(ValueTab[i])
            except:
                val = 0

            self.ScanAnyDegree.append(val)
            
    def SaveChoiceScanDegree(self, ScanTab):

        self.ScanFrontDegree = []

        for i in range(360 - HalfDegreeToTarget, 360):
            self.ScanFrontDegree.append(ScanTab[i])

        for i in range(HalfDegreeToTarget):
            self.ScanFrontDegree.append(ScanTab[i])


    #Permet le d√©placement du robot

    def Move(self, x, z):
        
        order = Twist()
        order.angular.z = z
        order.linear.x  = x
        self.publisher_.publish(order)

    def CalculatedMove(self, Tab):
        
        linearGap = Tab[0]
        angularGap = Tab[1]

        x = TargetAverageRange - linearGap
        y = - (20 - angularGap)
        

    # Algorythme du "Follow me"

    def TargetSaver(self, i):

        TargetMoy = (self.ScanAnyDegree[i] + self.ScanAnyDegree[i+1] + self.ScanAnyDegree[i+2] + self.ScanAnyDegree[i+3]) / 4

        if(TargetMinRange < TargetMoy < TargetMaxRange):

            Targets += [TargetMoy, i+1]

        i = 0 

        return 0

    def TargetIdentifier(self, i):

        validation = 0

        for j in [1, 2] : 

            if self.ScanAnyDegree[i+j] > self.ScanAnyDegree[i] + 0.30 | self.ScanAnyDegree[i+j] < self.ScanAnyDegree[i] - 0.30:

                break

            validation = validation + 1 

        i = 0 
        j = 0

        return validation

    def TargetCentral(self):
        
        for i in range(CalculatedDegreeToTarget) :

            validation = self.TargetIdentifier(i)
            
            if validation == 2 :

                self.TargetSaver()

    def ReachTarget(self):

        self.TargetCentral()

        NbTarget = len(Targets)
        
        if NbTarget > NbTargetMax | NbTarget == 0 :

            self.Move(0, 0)
        
        elif NbTarget > 1 :

            mem = 10

            for _ in range(NbTarget - 1) :

                if Targets[_][0] < mem :

                    mem = _

            self.CalculatedMove(Targets[mem])

        elif NbTarget == 1 :

            self.CalculatedMove(Targets[0])
        
        Targets = []





def main(args=None):

    rclpy.init(args=args)

    follow_me = FollowMe()

    rclpy.spin(follow_me)

    # Destroy the node explicitly
    # (optional - otherwise it will be done automatically
    # when the garbage collector destroys the node object)
    follow_me.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
